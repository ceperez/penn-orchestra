/*
 * Copyright (C) 2010 Trustees of the University of Pennsylvania
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS of ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package edu.upenn.cis.orchestra.mappings;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import edu.upenn.cis.orchestra.Debug;
import edu.upenn.cis.orchestra.datalog.atom.Atom;
import edu.upenn.cis.orchestra.datalog.atom.AtomArgument;
import edu.upenn.cis.orchestra.datalog.atom.AtomVariable;
import edu.upenn.cis.orchestra.datamodel.AbstractRelation;
import edu.upenn.cis.orchestra.datamodel.Mapping;
import edu.upenn.cis.orchestra.datamodel.Relation;
import edu.upenn.cis.orchestra.datamodel.RelationContext;
import edu.upenn.cis.orchestra.datamodel.RelationField;
import edu.upenn.cis.orchestra.datamodel.Schema;
import edu.upenn.cis.orchestra.datamodel.exceptions.IncompatibleTypesException;
import edu.upenn.cis.orchestra.exchange.RuleFieldMapping;

public class MappingsInversionMgt {

//	private static int indSkolem = 0;

		
	/**
	 * Inverse a set of mappings into a set of rules.
	 *   
	 * @param mappings Mappings to inverse
	 * @return List or rules resulting of inversion
	 */	
	public static List<Rule> inverseMappings (List<Mapping> mappings, Map<String, Schema> builtInSchemas)
	{
		List<Rule> res = new ArrayList<Rule> ();
		for (Mapping mapp : mappings)
			res.addAll (inverseMapping(mapp, builtInSchemas));
		return res;
	}
	
	/**
	 * Splits a mapping (with multiple atoms in the head) into rules, each with one head atom.
	 * If the mapping is already skolemized, it ensures that skolem atoms are put in the appropriate rules 
	 * (i.e., the ones for which the related variable appears in their head atom)
	 * 
	 * @param mapping The mapping to be split
	 * @return the list of rules
	 */	 
	public static List<Rule> splitMappingHead(Mapping mapping, Map<String, Schema> builtInSchemas){
		List<Rule> res = new ArrayList<Rule>();

		for(Atom a : mapping.getMappingHead()){
			List<Atom> stb = new ArrayList<Atom>();
			stb.addAll(mapping.copyBodyWithoutSkolems());
			stb.addAll(mapping.copySkolemAtomsForVars(a.getVariables()));
			Rule sp = new Rule(a, stb, mapping, builtInSchemas);
			sp.setFakeMapping(mapping.isFakeMapping());
			
			sp.setDerivedFrom(mapping.getId());
			res.add(sp);
		}
		return res;
	}

	public static List<Rule> splitMappingsHeads(List<Mapping> mappings, Map<String, Schema> builtInSchema){
		List<Rule> res = new ArrayList<Rule>();
		for(Mapping mapping : mappings){
			res.addAll(splitMappingHead(mapping, builtInSchema));
		}
		return res;
	}
	
	/**
	 * Inverse a mapping into a set of rules.
	 * Inversion process will:
	 *   - Replace variables declared in the head and not known in the body by autogenerated skolem
	 *     functions (these variables are a commodity for the user not to enter skolem functions by hand)
	 *   - User skolem function will be renamed with a namespace to avoid names conflicts
	 *   - Split the mappings into <head nb atoms> rules (a rule's head has only one atom)
	 *   
   	 *   Note: this method assumes that it is inverting rules of the form of "mapping projections",
	 *   i.e., there is a projection-free relation in the body
	 *   
	 *   Moreover, this method can alter the key of this mapping relation, adding to it parameters of
	 *   skolem functions that don't have the whole key of this mapping relation as a parameter
	 *   
	 * @param mapping Mapping to inverse
	 * @return List or rules resulting of inversion
	 */
	private static List<Rule> inverseMapping (Mapping mapping, Map<String, Schema> builtInSchemas){
		Mapping skolMapping = skolemizeMapping(mapping);
		
		return splitMappingHead(skolMapping, builtInSchemas);
	}
	
	/**
	 * Get the set of variables names defined in both the head and the body 
	 * of the mapping. <BR>
	 * Note: As a convenience to the user, a variable can be used only in the head 
	 * or in the body. This is an "implicit Skolem function" 
	 * @param mapping Mapping to get variables from
	 * @return Common variables names
	 */
	private static List<AtomVariable> getMappingCommonVariables (Mapping mapping)
	{
		List<AtomVariable> res ;
		List<AtomVariable> bodyVars;
		List<AtomVariable> headVars;
		
		bodyVars = getVariables (mapping.getBody());
		headVars = getVariables (mapping.getMappingHead());
		
		res = new ArrayList<AtomVariable> (headVars.size());
		
		for(AtomVariable var : bodyVars){
			if(headVars.contains(var) && !res.contains(var))
				res.add(var);
		}
		
//		res.addAll(headVars);
//		res.retainAll(bodyVars);
		
		return res;
	}
	
	/**
	 * Extract the set of variables names from a list of atoms.<BR>
	 * Any object of class ScMappingAtomValVariable or descendant 
	 * will be added to the result list...
	 * @param atoms Atoms from which to extract variables
	 * @return Set of variables names, can be empty but not null
	 */
	private static List<AtomVariable> getVariables (List<Atom> atoms)
	{
		List<AtomVariable> res = new ArrayList<AtomVariable> ();
		for (Atom atom : atoms)
			for (AtomArgument value : atom.getValues())
				if (value instanceof AtomVariable)
					if (!res.contains(((AtomVariable) value).getName()))
						res.add (((AtomVariable) value));
		//TODO: Extract vars from skolem too !!
		return res;
	}
	
	
	/**
	 * Creates a list of variables from a set or variables names
	 * @param varsNames Variables names
	 * @return List of variables (one per name)
	 */
	private static List<AtomArgument> duplicateAsVariables (List<AtomVariable> vars)
	{
		List<AtomArgument> res = new ArrayList<AtomArgument> ();
		
//		for (String varName : varsNames)
//			res.add (new ScMappingAtomValVariable (varName));
		for (AtomVariable var : vars)
			res.add(var.deepCopy());
			
		return res;
	}

	/**
	 * Call this method for a variable declared in a mapping head which is not 
	 * declared in the body. If this variable already has a skolem associated in 
	 * <code>skolems</code>, this skolem will be used. 
	 * Otherwise a new skolem with parameters <code>params</code> will be created, 
	 * <code>skolems</code> and then returned.
	 * @param varName Variable to replace with a skolem
	 * @param params Parameters to use if a new skolem is created
	 * @param skolems Skolems identified by the variables names that they are replacing
	 * @return The skolem to use to replace the variable <code>varName</code>
	 */
//	private static ScMappingAtomValSkolem createSkolem (String varName, 
//												List<ScMappingAtomValue> params,
//												Map<String, ScMappingAtomValSkolem> skolems)
//	{
//		ScMappingAtomValSkolem res;
//		if (skolems.containsKey(varName))
//			res = skolems.get(varName);
//		else
//		{
//			res = new ScMappingAtomValSkolem ("autoGen:f" + (indSkolem++), params);
//			skolems.put (varName, res);
//		}
//		return res;
//	}	
	
	private static Atom createSkolemAtom (AtomVariable variable, 
			List<AtomArgument> params, 
			Map<String, Atom> skolemAtoms, Mapping mapping, int skolemIndex) throws IncompatibleTypesException
	{
		String varName = variable.getName();
		List<AtomArgument> skolemParams = new ArrayList<AtomArgument>();
		skolemParams.add(variable);
		skolemParams.addAll(params);
		
		Atom res;
		if (skolemAtoms.containsKey(varName))
			res = skolemAtoms.get(varName);
		else
		{
//			ScMappingAtomValVariable skolemVar = new ScMappingAtomValVariable(varName);
//			skolemParams.add(0, skolemVar);
			
//			This should make skolemization "repeatable"
//			String skolemName = "autoGen:f" + (indSkolem++);
			String skolemName = "autoGen:f" + mapping.getId() + skolemIndex;
			
//			Need smth like RuleFieldMapping here - should move Zack's code to all rules ...
//			otherwise at least carry along types of fields next to "params"
//			for(){
//				
//			}
			List<RelationField> keyFields = new ArrayList<RelationField>();
			List<AtomArgument> keyParams = new ArrayList<AtomArgument>();
			List<RelationField> fields = getFieldsForSkolemParams(mapping, params, keyFields, keyParams);
			
			Relation rel = new Relation(null, null, skolemName, skolemName, "???", true, true, fields);
			RelationContext relCtx = new RelationContext(rel, null, null, false);
			res = new Atom(relCtx, skolemParams);
//			res.setSkolemKeyVals(params);
//			skolemVar.setSkolemDef(res);
			variable.setSkolemDef(res);
			skolemAtoms.put (varName, res);
			res.setSkolemKeyVals(keyParams);
//			res.setSkolemKeyVals(params);
		}
		return res;
	}	

	
	
	
	/**
	 * Call this method to rename a user skolem by adding a "namespace" extension to avoid 
	 * name conflicts
	 * @param skolem Skolem to rename
	 * @return Skolem renamed
	 */
	/*
	private static AtomSkolem renameUserSkolem (AtomSkolem skolem)
	{		
		AtomSkolem newSkolem = new AtomSkolem ("user:" + skolem.getName(), skolem.getParams());
		return newSkolem;
	}*/

	private static List<RelationField> getFieldsForSkolemParams(Mapping mapping, List<AtomArgument> params,
			List<RelationField> keyFields, List<AtomArgument> keyParams) throws IncompatibleTypesException{
		List<RelationField> fields = new ArrayList<RelationField>();

		List<RelationField> indexFields = new ArrayList<RelationField>();
		List<RuleFieldMapping> rfms = mapping.getRuleFieldMapping(indexFields, false);

		for(AtomArgument v : params){
			if(v instanceof AtomVariable){
				AtomVariable var1 = (AtomVariable)v;
				for(RuleFieldMapping rfm : rfms){
					if(rfm.srcArg instanceof AtomVariable && rfm.srcArg.toString().equals(var1.getName())){
						Debug.println("Found field for var: " + var1);
						fields.add(rfm.outputField);
						
						boolean fieldInSomeKey = false;
						for(RelationField srcField : rfm.srcColumns){
							AbstractRelation rel = srcField.getRelation();
							List<RelationField> key = rel.getPrimaryKey().getFields();
							if(key.contains(srcField)){
								for(RuleFieldMapping rr : rfms){
									if(rr.srcColumns.contains(srcField)){
										if(!keyParams.contains(rr.srcArg))
											keyParams.add(rr.srcArg);
										if(!keyFields.contains(srcField))
											keyFields.add(srcField);
										break;
									}
								}
								fieldInSomeKey = true;
								break;
							}
						}
						
//						This seems reasonable, but what we do right now is just compare normal attrs for 
//						key columns and attr_ln for non-key columns
						
//						if(!fieldInSomeKey){
//							RelationField srcField = rfm.srcColumns.get(0);
//							AbstractRelation rel = srcField.getRelation();
//							List<RelationField> key = rel.getPrimaryKey().getFields();
//							
//							for(RuleFieldMapping rr : rfms){
//								for(RelationField f : key){
//									if(rr.srcColumns.contains(f)){
//										if(!keyParams.contains(rr.srcArg))
//											keyParams.add(rr.srcArg);
//									}
//									if(!keyFields.contains(f))
//										keyFields.add(f);
//								}
//							}
//						}
					}
				}
			}else{
				Debug.println("Skolem has a non-var param!!! Should not happen ...");
				assert(false);
			}
		}

		return fields;
	}
	
	private static List<AtomArgument> getVarsForFields(Mapping mapping, Relation fieldsRel, List<RelationField> fields) throws IncompatibleTypesException
	{
		List<AtomArgument> vars = new ArrayList<AtomArgument>();

		List<RelationField> indexFields = new ArrayList<RelationField>();
		List<RuleFieldMapping> rfms = mapping.getRuleFieldMapping(indexFields, false);
		
		for(RelationField f : fields){
			if(f != null){
				for(RuleFieldMapping rfm : rfms){
					try{
						if(rfm.srcColumns.contains(fieldsRel.getDbRelName() + "." + f.getName())){
							if(rfm.srcArg instanceof AtomVariable){
								AtomVariable srcVar = (AtomVariable)rfm.srcArg;
								Debug.println("Found var: " + srcVar + " for: " + f);
								vars.add(srcVar);
							}else{
								Debug.println("Found non-var: " + rfm.srcArg + " for field" + f + " --- is this ok?");
								assert false;
							}
						}
					}catch(Exception e){
						e.printStackTrace();
					}
				}
			}
		}

		return vars;
	}

	/**
	 *   - Replace variables in the head and not in the body by autogenerated skolem
	 *     functions (these variables are a commodity for the user not to enter skolem functions by hand)
	 *   
	 * @param rules Mappings to inverse
	 * @return List or rules resulting of inversion
	 */	
	public static List<Rule> skolemizeRules (List<Rule> rules, Map<String, Schema> builtInSchemas)
	{
		List<Rule> res = new ArrayList<Rule> ();
		for (Rule r : rules)
			res.addAll(splitMappingHead(skolemizeMapping(r), builtInSchemas));
		return res;
	}


	/**
	 *   - Replace variables in the head and not in the body by autogenerated skolem
	 *     functions (these variables are a commodity for the user not to enter skolem functions by hand)
	 *   
	 *   Returns different skolem functions if called twice ...
	 *   
	 * @param mappings Mappings to inverse
	 * @return List or rules resulting of inversion
	 */	
	public static List<Mapping> skolemizeMappings (List<Mapping> mappings)
	{
		List<Mapping> res = new ArrayList<Mapping> ();
		for (Mapping mapp : mappings)
			res.add (skolemizeMapping(mapp));
		return res;
	}


	/**
	 *   - Replace variables declared in the head and not known in the body by autogenerated skolem
	 *     functions (these variables are a commodity for the user not to enter skolem functions by hand)
	 *
	 * @param mapping Mapping to inverse
	 * @return List or rules resulting of inversion
	 */
	public static Mapping skolemizeMapping (Mapping mapping)
	{
		int skolemIndex = 0;
		
		try{
			// First of all we have to rename the variables to avoid conflicts during composition
			// Eg if the user has a variable x and x1, there can be a conflict during composition
//
//		Do we really need this?
//			
//			mapping.renameVariables("_");

			Map<String, Atom> skolemAtoms = new HashMap<String, Atom> ();

//			List of common variables
			List<AtomVariable> commonVars = getMappingCommonVariables(mapping);

//			Do we really need to duplicate these?
//			Create the parameter list for generated skolem functions
			List<AtomArgument> params = duplicateAsVariables (commonVars);

//			May need to duplicate ...	
			List<Atom> newBody = new ArrayList<Atom>();
			newBody.addAll(mapping.getBody());

			List<AtomVariable> skolemizedVars = new ArrayList<AtomVariable>();
			//Note: Values added are not deep copies since atomValues are not supposed 
			// to be modified no need to increase memory allocation

			for (Atom headAtom : mapping.getMappingHead())
			{
				// Create the list of atom values.
				// Basically a copy of all variables / skolem / constants in which 
				// variables not shared with the body atoms are replaced by new skolems

				for (AtomArgument val : headAtom.getValues())
				{
					if (val instanceof AtomVariable)
					{
						AtomVariable var = (AtomVariable) val;
						if (!commonVars.contains(var) && !skolemizedVars.contains(var)){	// Existential var found
//							values.add(createSkolem(var.getName(), params, skolems));
//							New: introduce new autogen variable and create new "Skolem Atom"
//							Make sure this cannot go on forever

//							skolem params should only be the variables that appear on the head and are not skolems
//							How about constants?

//							This should always be the mapping rel in the body,
//							but we may want to add a backward reference from
//							ScField to TableSchema						


							List<AtomArgument> skolemParams = new ArrayList<AtomArgument>();
							skolemParams.addAll(params);
							

//							Since we have this "projection-free" mapping relation in the body, it suffices to
//							just use the key of the mapping relation as the skolem param, since it determines
//							all other attributes!
//
//							This may have worked when we inverted M to target mappings - not anymore ...
//							
//							List<AtomArgument> keyParams = new ArrayList<AtomArgument>();
//
//							for(Atom bodyAtom : mapping.getBody()){
//								List<RelationField> bodyKey;
//								Relation bodyRel = bodyAtom.getRelation();
//
//								if(bodyRel.getPrimaryKey() != null){
//									bodyKey = bodyRel.getPrimaryKey().getFields();
//								}else{
//									bodyKey = bodyRel.getFields();
//								}
//
//
////								List<ScField> fields = getFieldsForSkolemParams(mapping, params);
//								keyParams.addAll(getVarsForFields(mapping, bodyRel, bodyKey));
//							}
//
//							for(AtomArgument k : keyParams){
//								if(!skolemParams.contains(k))
//									skolemParams.add(k);
//							}

////							Alternative, more general code - do not delete
//
//							if(params.containsAll(keyParams)){
//								for(int i = 0; i < params.size(); i++){
//									if(keyParams.contains(params.get(i))){
//										skolemParams.add(params.get(i));
//									}
//								}
//							}else{
//								for(int i = 0; i < params.size(); i++){
//									if(!keyParams.contains(params.get(i))){
//
////							Should make sure that these fields are in the mapping rel
////							I think this is always true
//
//										mappingKey.add(mappingRel.getField(fields.get(i).getName()));
//									}
//								}
//
//								skolemParams.addAll(params);
//							}

							Atom skolemAtom = createSkolemAtom(var, skolemParams, skolemAtoms, mapping, skolemIndex++);
////							ScMappingAtom skolemAtom = createSkolemAtom(var, params, skolemAtoms, mapping);
							
////							Again, same as above this worked for M relation in the body ...
////							skolemAtom.setSkolemKeyVals(keyParams);
//							skolemAtom.setSkolemKeyVals(skolemParams);

							newBody.add(skolemAtom);
							var.setSkolemDef(skolemAtom);
							skolemizedVars.add(var);
						}
					}
				}
			}
//			Again, may need to duplicate
			List<Atom> newHead = new ArrayList<Atom>();
			newHead.addAll(mapping.getMappingHead());

			Mapping res = new Mapping(mapping.getId(), mapping.getDescription(), mapping.isMaterialized(), 
					mapping.isBidirectional(), mapping.getTrustRank(), newHead, newBody);
			res.setProvenanceRelation(mapping.getProvenanceRelation());
			res.setFakeMapping(mapping.isFakeMapping());
			
			res.setDerivedFrom(mapping.getId());
			
			// Mark the Skolem variables in the head
			for (Atom a : res.getMappingHead()) {
				int inx = 0;
				for (AtomVariable v : a.getVariables()) {
					if (skolemizedVars.contains(v))
						a.setIsNullable(inx);
					inx++;
				}
			}
			return res;
		}catch(IncompatibleTypesException e){
			Debug.println("Skolemization of mapping failed due to type error in the mapping");
			e.printStackTrace();
			return null;
		}


	}
}
